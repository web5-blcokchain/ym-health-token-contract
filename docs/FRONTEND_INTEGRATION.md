# ğŸš€ HealthLife Token (HLT) å‰ç«¯é›†æˆæ–‡æ¡£

## ğŸ“‹ ç›®å½•

1. [é¡¹ç›®æ¦‚è¿°](#é¡¹ç›®æ¦‚è¿°)
2. [åˆçº¦æ¶æ„](#åˆçº¦æ¶æ„)
3. [ç¯å¢ƒé…ç½®](#ç¯å¢ƒé…ç½®)
4. [åˆçº¦æ¥å£](#åˆçº¦æ¥å£)
5. [å‰ç«¯é›†æˆç¤ºä¾‹](#å‰ç«¯é›†æˆç¤ºä¾‹)
6. [å¸¸è§åœºæ™¯å®ç°](#å¸¸è§åœºæ™¯å®ç°)
7. [é”™è¯¯å¤„ç†](#é”™è¯¯å¤„ç†)
8. [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
9. [æµ‹è¯•æŒ‡å—](#æµ‹è¯•æŒ‡å—)
10. [FAQ](#faq)

## ğŸ“– é¡¹ç›®æ¦‚è¿°

HealthLife Token (HLT) æ˜¯ä¸€ä¸ªåŸºäºåŒºå—é“¾çš„å¥åº·åŒ»ç–—ä»£å¸é¡¹ç›®ï¼ŒåŒ…å«ä»¥ä¸‹æ ¸å¿ƒåŠŸèƒ½ï¼š

- **ERC-20ä»£å¸**: æ ‡å‡†çš„ä»¥å¤ªåŠä»£å¸ï¼Œæ€»ä¾›åº”é‡1äº¿æš
- **ä¼—ç­¹åŠŸèƒ½**: æ”¯æŒUSDTè´­ä¹°HLTä»£å¸ï¼Œæ±‡ç‡1 USDT = 12 HLT
- **é”ä»“æœºåˆ¶**: è´­ä¹°çš„ä»£å¸é”ä»“12ä¸ªæœˆ
- **ä»£å¸åˆ†é…**: 2400ä¸‡ç”¨äºå”®å–ï¼Œ7600ä¸‡è½¬ç»™æŒ‡å®šè´¦å·

### æ ¸å¿ƒç‰¹æ€§

- âœ… **å®‰å…¨æ€§**: åŸºäºOpenZeppelinåˆçº¦åº“
- âœ… **é€æ˜æ€§**: æ‰€æœ‰äº¤æ˜“å¯åœ¨åŒºå—é“¾ä¸ŠæŸ¥è¯¢
- âœ… **å¯æ‰©å±•æ€§**: æ”¯æŒå¤šç½‘ç»œéƒ¨ç½²ï¼ˆETHã€BSCï¼‰
- âœ… **ç”¨æˆ·å‹å¥½**: ç®€å•çš„è´­ä¹°æµç¨‹

## ğŸ—ï¸ åˆçº¦æ¶æ„

### åˆçº¦ç»„ä»¶

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   HLTToken.sol  â”‚    â”‚  Crowdsale.sol  â”‚    â”‚  MockUSDT.sol   â”‚
â”‚                 â”‚    â”‚                 â”‚    â”‚                 â”‚
â”‚ â€¢ ERC-20ä»£å¸    â”‚â—„â”€â”€â”€â”¤ â€¢ ä¼—ç­¹ç®¡ç†      â”‚â—„â”€â”€â”€â”¤ â€¢ æµ‹è¯•USDT     â”‚
â”‚ â€¢ é”ä»“åŠŸèƒ½      â”‚    â”‚ â€¢ ä»·æ ¼è®¾ç½®      â”‚    â”‚ â€¢ æ— é™é“¸é€       â”‚
â”‚ â€¢ æƒé™ç®¡ç†      â”‚    â”‚ â€¢ è´­ä¹°é€»è¾‘      â”‚    â”‚ â€¢ 6ä½å°æ•°      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ç½‘ç»œæ”¯æŒ

| ç½‘ç»œ | ChainID | RPC URL | çŠ¶æ€ |
|------|---------|---------|------|
| BSCæµ‹è¯•ç½‘ | 97 | https://data-seed-prebsc-1-s1.binance.org:8545/ | âœ… æ”¯æŒ |
| BSCä¸»ç½‘ | 56 | https://bsc-dataseed.binance.org/ | âœ… æ”¯æŒ |
| ETHä¸»ç½‘ | 1 | https://mainnet.infura.io/v3/... | âœ… æ”¯æŒ |
| ETHæµ‹è¯•ç½‘ | 5/11155111 | https://goerli.infura.io/v3/... | âœ… æ”¯æŒ |

## âš™ï¸ ç¯å¢ƒé…ç½®

### 1. å®‰è£…ä¾èµ–

```bash
# å®‰è£… ethers.js
npm install ethers

# æˆ–ä½¿ç”¨ web3.js
npm install web3

# æ¨èä½¿ç”¨ wagmi + viem (React)
npm install wagmi viem @tanstack/react-query
```

### 2. ç½‘ç»œé…ç½®

```javascript
// ç½‘ç»œé…ç½®
const networks = {
  bscTestnet: {
    chainId: 97,
    name: 'BSC Testnet',
    rpcUrl: 'https://data-seed-prebsc-1-s1.binance.org:8545/',
    blockExplorer: 'https://testnet.bscscan.com',
    nativeCurrency: {
      name: 'BNB',
      symbol: 'BNB',
      decimals: 18
    }
  },
  bscMainnet: {
    chainId: 56,
    name: 'BSC Mainnet',
    rpcUrl: 'https://bsc-dataseed.binance.org/',
    blockExplorer: 'https://bscscan.com',
    nativeCurrency: {
      name: 'BNB',
      symbol: 'BNB',
      decimals: 18
    }
  }
};
```

### 3. åˆçº¦åœ°å€é…ç½®

```javascript
// åˆçº¦åœ°å€é…ç½®ï¼ˆè¯·æ›¿æ¢ä¸ºå®é™…éƒ¨ç½²åœ°å€ï¼‰
const contractAddresses = {
  bscTestnet: {
    HLTToken: '0x...', // HLTä»£å¸åˆçº¦åœ°å€
    Crowdsale: '0x...', // ä¼—ç­¹åˆçº¦åœ°å€
    USDT: '0x...' // USDTåˆçº¦åœ°å€
  },
  bscMainnet: {
    HLTToken: '0x...',
    Crowdsale: '0x...',
    USDT: '0x55d398326f99059fF775485246999027B3197955' // BSCä¸»ç½‘USDT
  }
};
```

## ğŸ“‹ åˆçº¦æ¥å£

### HLTToken åˆçº¦æ¥å£

#### åŸºç¡€ä¿¡æ¯æŸ¥è¯¢

```javascript
// ä»£å¸åŸºç¡€ä¿¡æ¯
const tokenInfo = {
  name: await hltToken.name(), // "HealthLife Token"
  symbol: await hltToken.symbol(), // "HLT"
  decimals: await hltToken.decimals(), // 18
  totalSupply: await hltToken.totalSupply() // 100,000,000 * 10^18
};

// ä»£å¸åˆ†é…ä¿¡æ¯
const allocation = {
  totalSupply: await hltToken.TOTAL_SUPPLY(), // 1äº¿ä»£å¸
  saleAmount: await hltToken.SALE_AMOUNT(), // 2400ä¸‡ä»£å¸
  otherAmount: await hltToken.OTHER_AMOUNT() // 7600ä¸‡ä»£å¸
};
```

#### ä½™é¢å’Œæˆæƒ

```javascript
// æŸ¥è¯¢ç”¨æˆ·ä½™é¢
const balance = await hltToken.balanceOf(userAddress);

// æŸ¥è¯¢æˆæƒé¢åº¦
const allowance = await hltToken.allowance(userAddress, spenderAddress);

// æˆæƒä»£å¸
const approveTx = await hltToken.approve(spenderAddress, amount);
await approveTx.wait();
```

#### é”ä»“åŠŸèƒ½

```javascript
// æŸ¥è¯¢ç”¨æˆ·æ˜¯å¦è¢«é”ä»“
const isLocked = await hltToken.isUserLocked(userAddress);

// æŸ¥è¯¢ç”¨æˆ·è§£é”æ—¶é—´
const unlockTime = await hltToken.getUserUnlockTime(userAddress);

// æŸ¥è¯¢å‰©ä½™é”ä»“æ—¶é—´ï¼ˆç§’ï¼‰
const remainingTime = await hltToken.getUserRemainingLockTime(userAddress);

// æŸ¥è¯¢ç”¨æˆ·é”ä»“å¼€å§‹æ—¶é—´
const lockTime = await hltToken.userLockTime(userAddress);
```

### Crowdsale åˆçº¦æ¥å£

#### ä¼—ç­¹çŠ¶æ€æŸ¥è¯¢

```javascript
// æŸ¥è¯¢ä¼—ç­¹çŠ¶æ€
const crowdsaleStatus = await crowdsale.getCrowdsaleStatus();
const {
  active,      // æ˜¯å¦æ´»è·ƒ
  ended,       // æ˜¯å¦ç»“æŸ
  startTime,   // å¼€å§‹æ—¶é—´
  endTime      // ç»“æŸæ—¶é—´
} = crowdsaleStatus;

// æŸ¥è¯¢ä»£å¸ä»·æ ¼
const tokensPerUSDT = await crowdsale.getTokenPrice(); // é»˜è®¤12

// æŸ¥è¯¢è´­ä¹°é™åˆ¶
const minPurchase = await crowdsale.MIN_PURCHASE_USDT(); // 1 USDT
const maxPurchase = await crowdsale.MAX_PURCHASE_USDT(); // 100ä¸‡ USDT
```

#### ä¼—ç­¹ç»Ÿè®¡

```javascript
// æŸ¥è¯¢ä¼—ç­¹ç»Ÿè®¡æ•°æ®
const stats = await crowdsale.getCrowdsaleStats();
const {
  totalUSDTRaised,    // æ€»ç­¹é›†USDT
  totalHLTSold,       // æ€»å”®å‡ºHLT
  totalParticipants   // æ€»å‚ä¸äººæ•°
} = stats;
```

#### ç”¨æˆ·ä¿¡æ¯æŸ¥è¯¢

```javascript
// æŸ¥è¯¢ç”¨æˆ·è´­ä¹°ä¿¡æ¯
const userInfo = await crowdsale.getUserInfo(userAddress);
const {
  usdtPurchased,  // ç”¨æˆ·è´­ä¹°çš„USDTæ•°é‡
  hltAmount,      // ç”¨æˆ·è·å¾—çš„HLTæ•°é‡
  participated    // æ˜¯å¦å‚ä¸è¿‡
} = userInfo;
```

#### ä»·æ ¼è®¡ç®—

```javascript
// è®¡ç®—USDTå¯è´­ä¹°çš„HLTæ•°é‡
const usdtAmount = ethers.utils.parseUnits("100", 6); // 100 USDT
const hltAmount = await crowdsale.calculateHLTAmount(usdtAmount);

// è®¡ç®—è´­ä¹°æŒ‡å®šHLTéœ€è¦çš„USDTæ•°é‡
const hltDesired = ethers.utils.parseEther("1200"); // 1200 HLT
const usdtNeeded = await crowdsale.calculateUSDTAmount(hltDesired);
```

### USDT åˆçº¦æ¥å£

```javascript
// USDTåŸºç¡€ä¿¡æ¯
const usdtInfo = {
  name: await usdtToken.name(), // "Tether USD"
  symbol: await usdtToken.symbol(), // "USDT"
  decimals: await usdtToken.decimals() // 6
};

// æŸ¥è¯¢USDTä½™é¢
const usdtBalance = await usdtToken.balanceOf(userAddress);

// æˆæƒUSDTç»™ä¼—ç­¹åˆçº¦
const approveUSDT = await usdtToken.approve(crowdsaleAddress, amount);
```

## ğŸ’» å‰ç«¯é›†æˆç¤ºä¾‹

### 1. ä½¿ç”¨ ethers.js

```javascript
import { ethers } from 'ethers';

// åˆçº¦ABIï¼ˆç®€åŒ–ç‰ˆï¼‰
const HLT_ABI = [
  "function name() view returns (string)",
  "function symbol() view returns (string)",
  "function decimals() view returns (uint8)",
  "function totalSupply() view returns (uint256)",
  "function balanceOf(address) view returns (uint256)",
  "function transfer(address to, uint256 amount) returns (bool)",
  "function approve(address spender, uint256 amount) returns (bool)",
  "function allowance(address owner, address spender) view returns (uint256)",
  "function isUserLocked(address user) view returns (bool)",
  "function getUserUnlockTime(address user) view returns (uint256)",
  "function getUserRemainingLockTime(address user) view returns (uint256)"
];

const CROWDSALE_ABI = [
  "function buyTokens(uint256 usdtAmount)",
  "function getCrowdsaleStatus() view returns (bool active, bool ended, uint256 startTime, uint256 endTime)",
  "function getTokenPrice() view returns (uint256)",
  "function getUserInfo(address user) view returns (uint256 usdtPurchased, uint256 hltAmount, bool participated)",
  "function calculateHLTAmount(uint256 usdtAmount) view returns (uint256)",
  "function calculateUSDTAmount(uint256 hltAmount) view returns (uint256)"
];

const USDT_ABI = [
  "function name() view returns (string)",
  "function symbol() view returns (string)",
  "function decimals() view returns (uint8)",
  "function balanceOf(address) view returns (uint256)",
  "function approve(address spender, uint256 amount) returns (bool)",
  "function allowance(address owner, address spender) view returns (uint256)"
];

class HLTIntegration {
  constructor(provider, contractAddresses) {
    this.provider = provider;
    this.addresses = contractAddresses;
    
    // åˆå§‹åŒ–åˆçº¦å®ä¾‹
    this.hltToken = new ethers.Contract(contractAddresses.HLTToken, HLT_ABI, provider);
    this.crowdsale = new ethers.Contract(contractAddresses.Crowdsale, CROWDSALE_ABI, provider);
    this.usdtToken = new ethers.Contract(contractAddresses.USDT, USDT_ABI, provider);
  }

  // è¿æ¥é’±åŒ…
  async connectWallet() {
    if (typeof window.ethereum !== 'undefined') {
      await window.ethereum.request({ method: 'eth_requestAccounts' });
      this.signer = this.provider.getSigner();
      this.userAddress = await this.signer.getAddress();
      
      // è¿æ¥åˆçº¦åˆ°ç­¾åè€…
      this.hltToken = this.hltToken.connect(this.signer);
      this.crowdsale = this.crowdsale.connect(this.signer);
      this.usdtToken = this.usdtToken.connect(this.signer);
      
      return this.userAddress;
    }
    throw new Error('è¯·å®‰è£…MetaMask');
  }

  // è·å–ç”¨æˆ·ä¿¡æ¯
  async getUserInfo() {
    if (!this.userAddress) throw new Error('è¯·å…ˆè¿æ¥é’±åŒ…');
    
    const [hltBalance, usdtBalance, isLocked, unlockTime, userInfo] = await Promise.all([
      this.hltToken.balanceOf(this.userAddress),
      this.usdtToken.balanceOf(this.userAddress),
      this.hltToken.isUserLocked(this.userAddress),
      this.hltToken.getUserUnlockTime(this.userAddress),
      this.crowdsale.getUserInfo(this.userAddress)
    ]);

    return {
      address: this.userAddress,
      hltBalance: ethers.utils.formatEther(hltBalance),
      usdtBalance: ethers.utils.formatUnits(usdtBalance, 6),
      isLocked,
      unlockTime: unlockTime.toNumber(),
      purchased: {
        usdtAmount: ethers.utils.formatUnits(userInfo.usdtPurchased, 6),
        hltAmount: ethers.utils.formatEther(userInfo.hltAmount),
        participated: userInfo.participated
      }
    };
  }

  // è·å–ä¼—ç­¹ä¿¡æ¯
  async getCrowdsaleInfo() {
    const [status, price, stats] = await Promise.all([
      this.crowdsale.getCrowdsaleStatus(),
      this.crowdsale.getTokenPrice(),
      this.crowdsale.getCrowdsaleStats()
    ]);

    return {
      active: status.active,
      ended: status.ended,
      startTime: status.startTime.toNumber(),
      endTime: status.endTime.toNumber(),
      price: price.toNumber(),
      stats: {
        totalUSDTRaised: ethers.utils.formatUnits(stats.totalUSDTRaised, 6),
        totalHLTSold: ethers.utils.formatEther(stats.totalHLTSold),
        totalParticipants: stats.totalParticipants.toNumber()
      }
    };
  }

  // è´­ä¹°ä»£å¸
  async buyTokens(usdtAmount) {
    if (!this.userAddress) throw new Error('è¯·å…ˆè¿æ¥é’±åŒ…');
    
    const usdtAmountWei = ethers.utils.parseUnits(usdtAmount.toString(), 6);
    
    // 1. æ£€æŸ¥USDTä½™é¢
    const usdtBalance = await this.usdtToken.balanceOf(this.userAddress);
    if (usdtBalance.lt(usdtAmountWei)) {
      throw new Error('USDTä½™é¢ä¸è¶³');
    }
    
    // 2. æ£€æŸ¥æˆæƒ
    const allowance = await this.usdtToken.allowance(this.userAddress, this.addresses.Crowdsale);
    if (allowance.lt(usdtAmountWei)) {
      // éœ€è¦æˆæƒ
      const approveTx = await this.usdtToken.approve(this.addresses.Crowdsale, usdtAmountWei);
      await approveTx.wait();
    }
    
    // 3. è´­ä¹°ä»£å¸
    const buyTx = await this.crowdsale.buyTokens(usdtAmountWei);
    const receipt = await buyTx.wait();
    
    return {
      transactionHash: receipt.transactionHash,
      blockNumber: receipt.blockNumber,
      gasUsed: receipt.gasUsed.toString()
    };
  }

  // è®¡ç®—è´­ä¹°é¢„è§ˆ
  async calculatePurchase(usdtAmount) {
    const usdtAmountWei = ethers.utils.parseUnits(usdtAmount.toString(), 6);
    const hltAmount = await this.crowdsale.calculateHLTAmount(usdtAmountWei);
    
    return {
      usdtAmount: usdtAmount,
      hltAmount: ethers.utils.formatEther(hltAmount),
      price: await this.crowdsale.getTokenPrice()
    };
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const provider = new ethers.providers.Web3Provider(window.ethereum);
const hlt = new HLTIntegration(provider, contractAddresses.bscTestnet);

// è¿æ¥é’±åŒ…å¹¶è·å–ä¿¡æ¯
async function init() {
  try {
    await hlt.connectWallet();
    const userInfo = await hlt.getUserInfo();
    const crowdsaleInfo = await hlt.getCrowdsaleInfo();
    
    console.log('ç”¨æˆ·ä¿¡æ¯:', userInfo);
    console.log('ä¼—ç­¹ä¿¡æ¯:', crowdsaleInfo);
  } catch (error) {
    console.error('åˆå§‹åŒ–å¤±è´¥:', error);
  }
}
```

### 2. ä½¿ç”¨ React + wagmi

```jsx
import { useAccount, useContractRead, useContractWrite, usePrepareContractWrite } from 'wagmi';
import { parseUnits, formatUnits } from 'viem';

// React Hook ç¤ºä¾‹
function useCrowdsale(contractAddress) {
  const { address } = useAccount();
  
  // è¯»å–ä¼—ç­¹çŠ¶æ€
  const { data: crowdsaleStatus } = useContractRead({
    address: contractAddress,
    abi: CROWDSALE_ABI,
    functionName: 'getCrowdsaleStatus'
  });
  
  // è¯»å–ç”¨æˆ·ä¿¡æ¯
  const { data: userInfo } = useContractRead({
    address: contractAddress,
    abi: CROWDSALE_ABI,
    functionName: 'getUserInfo',
    args: [address],
    enabled: !!address
  });
  
  return {
    crowdsaleStatus,
    userInfo,
    isActive: crowdsaleStatus?.[0],
    isEnded: crowdsaleStatus?.[1]
  };
}

// è´­ä¹°ç»„ä»¶
function BuyTokens({ crowdsaleAddress, usdtAddress }) {
  const [usdtAmount, setUsdtAmount] = useState('');
  const { address } = useAccount();
  
  // å‡†å¤‡è´­ä¹°äº¤æ˜“
  const { config } = usePrepareContractWrite({
    address: crowdsaleAddress,
    abi: CROWDSALE_ABI,
    functionName: 'buyTokens',
    args: [parseUnits(usdtAmount || '0', 6)],
    enabled: !!usdtAmount && parseFloat(usdtAmount) > 0
  });
  
  const { write: buyTokens, isLoading } = useContractWrite(config);
  
  // å‡†å¤‡æˆæƒäº¤æ˜“
  const { config: approveConfig } = usePrepareContractWrite({
    address: usdtAddress,
    abi: USDT_ABI,
    functionName: 'approve',
    args: [crowdsaleAddress, parseUnits(usdtAmount || '0', 6)],
    enabled: !!usdtAmount && parseFloat(usdtAmount) > 0
  });
  
  const { write: approveUSDT, isLoading: isApproving } = useContractWrite(approveConfig);
  
  const handleBuy = async () => {
    if (!usdtAmount) return;
    
    try {
      // å…ˆæˆæƒï¼Œå†è´­ä¹°
      await approveUSDT?.();
      await buyTokens?.();
    } catch (error) {
      console.error('è´­ä¹°å¤±è´¥:', error);
    }
  };
  
  return (
    <div className="buy-tokens">
      <h3>è´­ä¹° HLT ä»£å¸</h3>
      <div>
        <label>USDT æ•°é‡:</label>
        <input
          type="number"
          value={usdtAmount}
          onChange={(e) => setUsdtAmount(e.target.value)}
          placeholder="è¾“å…¥USDTæ•°é‡"
        />
      </div>
      <div>
        <p>å°†è·å¾—: {usdtAmount ? (parseFloat(usdtAmount) * 12).toFixed(2) : '0'} HLT</p>
      </div>
      <button
        onClick={handleBuy}
        disabled={!usdtAmount || isLoading || isApproving}
      >
        {isApproving ? 'æˆæƒä¸­...' : isLoading ? 'è´­ä¹°ä¸­...' : 'è´­ä¹°ä»£å¸'}
      </button>
    </div>
  );
}
```

## ğŸ¯ å¸¸è§åœºæ™¯å®ç°

### 1. ç”¨æˆ·é’±åŒ…è¿æ¥

```javascript
// MetaMask è¿æ¥
async function connectMetaMask() {
  if (typeof window.ethereum !== 'undefined') {
    try {
      // è¯·æ±‚è¿æ¥
      await window.ethereum.request({ method: 'eth_requestAccounts' });
      
      // æ£€æŸ¥ç½‘ç»œ
      const chainId = await window.ethereum.request({ method: 'eth_chainId' });
      if (chainId !== '0x61') { // BSCæµ‹è¯•ç½‘
        await switchToBSCTestnet();
      }
      
      return true;
    } catch (error) {
      console.error('è¿æ¥å¤±è´¥:', error);
      return false;
    }
  } else {
    alert('è¯·å®‰è£…MetaMask');
    return false;
  }
}

// åˆ‡æ¢åˆ°BSCæµ‹è¯•ç½‘
async function switchToBSCTestnet() {
  try {
    await window.ethereum.request({
      method: 'wallet_switchEthereumChain',
      params: [{ chainId: '0x61' }]
    });
  } catch (switchError) {
    // å¦‚æœç½‘ç»œä¸å­˜åœ¨ï¼Œæ·»åŠ ç½‘ç»œ
    if (switchError.code === 4902) {
      await window.ethereum.request({
        method: 'wallet_addEthereumChain',
        params: [{
          chainId: '0x61',
          chainName: 'BSC Testnet',
          nativeCurrency: {
            name: 'BNB',
            symbol: 'BNB',
            decimals: 18
          },
          rpcUrls: ['https://data-seed-prebsc-1-s1.binance.org:8545/'],
          blockExplorerUrls: ['https://testnet.bscscan.com']
        }]
      });
    }
  }
}
```

### 2. å®æ—¶æ•°æ®æ›´æ–°

```javascript
// ä½¿ç”¨äº‹ä»¶ç›‘å¬å®æ—¶æ›´æ–°
class RealTimeUpdater {
  constructor(contracts) {
    this.contracts = contracts;
    this.listeners = [];
  }
  
  // ç›‘å¬ä»£å¸è´­ä¹°äº‹ä»¶
  listenToPurchaseEvents(callback) {
    const filter = this.contracts.crowdsale.filters.TokensPurchased();
    
    this.contracts.crowdsale.on(filter, (buyer, usdtAmount, hltAmount, lockTime, timestamp, event) => {
      callback({
        buyer,
        usdtAmount: ethers.utils.formatUnits(usdtAmount, 6),
        hltAmount: ethers.utils.formatEther(hltAmount),
        lockTime: lockTime.toNumber(),
        timestamp: timestamp.toNumber(),
        transactionHash: event.transactionHash
      });
    });
  }
  
  // ç›‘å¬ä¼—ç­¹çŠ¶æ€å˜åŒ–
  listenToCrowdsaleEvents(callback) {
    // ç›‘å¬ä¼—ç­¹å¼€å§‹
    this.contracts.crowdsale.on('CrowdsaleStarted', (startTime, event) => {
      callback({ type: 'started', startTime: startTime.toNumber(), event });
    });
    
    // ç›‘å¬ä¼—ç­¹ç»“æŸ
    this.contracts.crowdsale.on('CrowdsaleEnded', (endTime, totalUSDT, totalHLT, event) => {
      callback({
        type: 'ended',
        endTime: endTime.toNumber(),
        totalUSDT: ethers.utils.formatUnits(totalUSDT, 6),
        totalHLT: ethers.utils.formatEther(totalHLT),
        event
      });
    });
  }
  
  // æ¸…ç†ç›‘å¬å™¨
  cleanup() {
    this.contracts.crowdsale.removeAllListeners();
  }
}
```

### 3. äº¤æ˜“çŠ¶æ€è·Ÿè¸ª

```javascript
// äº¤æ˜“çŠ¶æ€è·Ÿè¸ªå™¨
class TransactionTracker {
  constructor(provider) {
    this.provider = provider;
    this.pendingTxs = new Map();
  }
  
  // è·Ÿè¸ªäº¤æ˜“
  async trackTransaction(txHash, description) {
    this.pendingTxs.set(txHash, { description, status: 'pending' });
    
    try {
      // ç­‰å¾…äº¤æ˜“ç¡®è®¤
      const receipt = await this.provider.waitForTransaction(txHash, 1);
      
      if (receipt.status === 1) {
        this.pendingTxs.set(txHash, { description, status: 'success', receipt });
        return { success: true, receipt };
      } else {
        this.pendingTxs.set(txHash, { description, status: 'failed', receipt });
        return { success: false, receipt };
      }
    } catch (error) {
      this.pendingTxs.set(txHash, { description, status: 'error', error });
      return { success: false, error };
    }
  }
  
  // è·å–äº¤æ˜“çŠ¶æ€
  getTransactionStatus(txHash) {
    return this.pendingTxs.get(txHash);
  }
  
  // è·å–æ‰€æœ‰å¾…å¤„ç†äº¤æ˜“
  getPendingTransactions() {
    return Array.from(this.pendingTxs.entries())
      .filter(([_, tx]) => tx.status === 'pending');
  }
}
```

### 4. é”™è¯¯å¤„ç†å’Œç”¨æˆ·æç¤º

```javascript
// é”™è¯¯å¤„ç†å·¥å…·
class ErrorHandler {
  static parseError(error) {
    // ç”¨æˆ·æ‹’ç»äº¤æ˜“
    if (error.code === 4001) {
      return {
        type: 'USER_REJECTED',
        message: 'ç”¨æˆ·å–æ¶ˆäº†äº¤æ˜“',
        userFriendly: 'æ‚¨å–æ¶ˆäº†äº¤æ˜“ï¼Œè¯·é‡è¯•'
      };
    }
    
    // ä½™é¢ä¸è¶³
    if (error.message.includes('insufficient funds')) {
      return {
        type: 'INSUFFICIENT_FUNDS',
        message: 'ä½™é¢ä¸è¶³',
        userFriendly: 'æ‚¨çš„ä½™é¢ä¸è¶³ä»¥å®Œæˆæ­¤äº¤æ˜“'
      };
    }
    
    // åˆçº¦é”™è¯¯
    if (error.message.includes('execution reverted')) {
      const reason = this.extractRevertReason(error.message);
      return {
        type: 'CONTRACT_ERROR',
        message: reason,
        userFriendly: this.getContractErrorMessage(reason)
      };
    }
    
    // ç½‘ç»œé”™è¯¯
    if (error.message.includes('network')) {
      return {
        type: 'NETWORK_ERROR',
        message: 'ç½‘ç»œè¿æ¥é”™è¯¯',
        userFriendly: 'ç½‘ç»œè¿æ¥ä¸ç¨³å®šï¼Œè¯·æ£€æŸ¥ç½‘ç»œåé‡è¯•'
      };
    }
    
    return {
      type: 'UNKNOWN_ERROR',
      message: error.message,
      userFriendly: 'å‘ç”ŸæœªçŸ¥é”™è¯¯ï¼Œè¯·é‡è¯•'
    };
  }
  
  static extractRevertReason(errorMessage) {
    const match = errorMessage.match(/execution reverted: (.+)/);
    return match ? match[1] : 'åˆçº¦æ‰§è¡Œå¤±è´¥';
  }
  
  static getContractErrorMessage(reason) {
    const errorMessages = {
      'Crowdsale not active': 'ä¼—ç­¹å°šæœªå¼€å§‹æˆ–å·²ç»“æŸ',
      'Amount too small': 'è´­ä¹°æ•°é‡å¤ªå°‘ï¼Œæœ€å°‘éœ€è¦1 USDT',
      'Amount too large': 'è´­ä¹°æ•°é‡å¤ªå¤šï¼Œæœ€å¤š100ä¸‡ USDT',
      'Insufficient token balance': 'åˆçº¦ä»£å¸ä½™é¢ä¸è¶³',
      'Insufficient USDT allowance': 'è¯·å…ˆæˆæƒUSDT',
      'USDT transfer failed': 'USDTè½¬è´¦å¤±è´¥',
      'Token transfer failed': 'ä»£å¸è½¬è´¦å¤±è´¥',
      'Tokens are locked for 12 months': 'ä»£å¸å·²é”ä»“12ä¸ªæœˆï¼Œæš‚æ—¶æ— æ³•è½¬è´¦'
    };
    
    return errorMessages[reason] || reason;
  }
}
```

## âš ï¸ é”™è¯¯å¤„ç†

### å¸¸è§é”™è¯¯ç±»å‹

| é”™è¯¯ç±»å‹ | åŸå›  | è§£å†³æ–¹æ¡ˆ |
|----------|------|----------|
| `USER_REJECTED` | ç”¨æˆ·å–æ¶ˆäº¤æ˜“ | æç¤ºç”¨æˆ·é‡æ–°æ“ä½œ |
| `INSUFFICIENT_FUNDS` | ä½™é¢ä¸è¶³ | æ£€æŸ¥ç”¨æˆ·ä½™é¢ï¼Œæç¤ºå……å€¼ |
| `NETWORK_ERROR` | ç½‘ç»œé—®é¢˜ | æ£€æŸ¥ç½‘ç»œè¿æ¥ï¼Œé‡è¯• |
| `CONTRACT_ERROR` | åˆçº¦æ‰§è¡Œå¤±è´¥ | æ ¹æ®å…·ä½“é”™è¯¯æç¤ºç”¨æˆ· |
| `INVALID_AMOUNT` | é‡‘é¢æ— æ•ˆ | éªŒè¯è¾“å…¥é‡‘é¢èŒƒå›´ |

### é”™è¯¯å¤„ç†ç¤ºä¾‹

```javascript
// å®Œæ•´çš„è´­ä¹°æµç¨‹é”™è¯¯å¤„ç†
async function safeBuyTokens(usdtAmount) {
  try {
    // 1. è¾“å…¥éªŒè¯
    if (!usdtAmount || parseFloat(usdtAmount) <= 0) {
      throw new Error('è¯·è¾“å…¥æœ‰æ•ˆçš„USDTæ•°é‡');
    }
    
    if (parseFloat(usdtAmount) < 1) {
      throw new Error('æœ€å°‘è´­ä¹°1 USDT');
    }
    
    if (parseFloat(usdtAmount) > 1000000) {
      throw new Error('æœ€å¤šè´­ä¹°100ä¸‡ USDT');
    }
    
    // 2. æ£€æŸ¥ä¼—ç­¹çŠ¶æ€
    const crowdsaleInfo = await hlt.getCrowdsaleInfo();
    if (!crowdsaleInfo.active) {
      throw new Error('ä¼—ç­¹å°šæœªå¼€å§‹æˆ–å·²ç»“æŸ');
    }
    
    // 3. æ£€æŸ¥ç”¨æˆ·ä½™é¢
    const userInfo = await hlt.getUserInfo();
    if (parseFloat(userInfo.usdtBalance) < parseFloat(usdtAmount)) {
      throw new Error('USDTä½™é¢ä¸è¶³');
    }
    
    // 4. æ‰§è¡Œè´­ä¹°
    const result = await hlt.buyTokens(usdtAmount);
    
    // 5. æˆåŠŸæç¤º
    showSuccess(`è´­ä¹°æˆåŠŸï¼äº¤æ˜“å“ˆå¸Œ: ${result.transactionHash}`);
    
    return result;
    
  } catch (error) {
    const parsedError = ErrorHandler.parseError(error);
    showError(parsedError.userFriendly);
    throw parsedError;
  }
}

// ç”¨æˆ·ç•Œé¢æç¤ºå‡½æ•°
function showSuccess(message) {
  // æ˜¾ç¤ºæˆåŠŸæç¤º
  console.log('âœ…', message);
}

function showError(message) {
  // æ˜¾ç¤ºé”™è¯¯æç¤º
  console.error('âŒ', message);
}
```

## ğŸ† æœ€ä½³å®è·µ

### 1. å®‰å…¨æ€§

```javascript
// âœ… å¥½çš„åšæ³•
// 1. å§‹ç»ˆéªŒè¯ç”¨æˆ·è¾“å…¥
function validateUSDTAmount(amount) {
  const num = parseFloat(amount);
  if (isNaN(num) || num <= 0) {
    throw new Error('è¯·è¾“å…¥æœ‰æ•ˆæ•°å­—');
  }
  if (num < 1) {
    throw new Error('æœ€å°‘è´­ä¹°1 USDT');
  }
  if (num > 1000000) {
    throw new Error('æœ€å¤šè´­ä¹°100ä¸‡ USDT');
  }
  return true;
}

// 2. æ£€æŸ¥åˆçº¦çŠ¶æ€
async function checkContractState() {
  const crowdsaleInfo = await hlt.getCrowdsaleInfo();
  if (!crowdsaleInfo.active) {
    throw new Error('ä¼—ç­¹æœªæ¿€æ´»');
  }
  return true;
}

// 3. ä½¿ç”¨try-catchåŒ…è£…æ‰€æœ‰å¼‚æ­¥æ“ä½œ
async function safeContractCall(operation) {
  try {
    return await operation();
  } catch (error) {
    const parsedError = ErrorHandler.parseError(error);
    throw parsedError;
  }
}
```

### 2. æ€§èƒ½ä¼˜åŒ–

```javascript
// âœ… æ‰¹é‡æŸ¥è¯¢å‡å°‘RPCè°ƒç”¨
async function getBatchUserInfo(userAddress) {
  const [hltBalance, usdtBalance, isLocked, userInfo, crowdsaleStatus] = await Promise.all([
    hlt.hltToken.balanceOf(userAddress),
    hlt.usdtToken.balanceOf(userAddress),
    hlt.hltToken.isUserLocked(userAddress),
    hlt.crowdsale.getUserInfo(userAddress),
    hlt.crowdsale.getCrowdsaleStatus()
  ]);
  
  return {
    hltBalance: ethers.utils.formatEther(hltBalance),
    usdtBalance: ethers.utils.formatUnits(usdtBalance, 6),
    isLocked,
    userInfo,
    crowdsaleStatus
  };
}

// âœ… ç¼“å­˜åˆçº¦å®ä¾‹
const contractCache = new Map();

function getContract(address, abi, provider) {
  const key = `${address}-${provider.network?.chainId}`;
  if (!contractCache.has(key)) {
    contractCache.set(key, new ethers.Contract(address, abi, provider));
  }
  return contractCache.get(key);
}
```

### 3. ç”¨æˆ·ä½“éªŒ

```javascript
// âœ… æä¾›å®æ—¶åé¦ˆ
class UIFeedback {
  static showLoading(message = 'å¤„ç†ä¸­...') {
    // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
    console.log('â³', message);
  }
  
  static hideLoading() {
    // éšè—åŠ è½½çŠ¶æ€
  }
  
  static showProgress(current, total, message) {
    const percentage = Math.round((current / total) * 100);
    console.log(`ğŸ“Š ${message}: ${percentage}%`);
  }
  
  static showTransactionPending(txHash) {
    console.log(`â³ äº¤æ˜“æäº¤æˆåŠŸï¼Œç­‰å¾…ç¡®è®¤: ${txHash}`);
  }
  
  static showTransactionSuccess(txHash, message) {
    console.log(`âœ… ${message}ï¼Œäº¤æ˜“å“ˆå¸Œ: ${txHash}`);
  }
}

// âœ… é¢„ä¼°Gasè´¹ç”¨
async function estimateGasCost(contractMethod, args) {
  try {
    const gasEstimate = await contractMethod.estimateGas(...args);
    const gasPrice = await provider.getGasPrice();
    const gasCost = gasEstimate.mul(gasPrice);
    
    return {
      gasLimit: gasEstimate.toString(),
      gasPrice: ethers.utils.formatUnits(gasPrice, 'gwei'),
      estimatedCost: ethers.utils.formatEther(gasCost)
    };
  } catch (error) {
    console.error('Gasä¼°ç®—å¤±è´¥:', error);
    return null;
  }
}
```

## ğŸ§ª æµ‹è¯•æŒ‡å—

### 1. å•å…ƒæµ‹è¯•

```javascript
// ä½¿ç”¨ Jest + ethers.js è¿›è¡Œæµ‹è¯•
describe('HLT Integration Tests', () => {
  let hlt;
  let mockProvider;
  
  beforeEach(() => {
    mockProvider = new MockProvider();
    hlt = new HLTIntegration(mockProvider, testContractAddresses);
  });
  
  test('åº”è¯¥æ­£ç¡®è®¡ç®—è´­ä¹°é¢„è§ˆ', async () => {
    const preview = await hlt.calculatePurchase(100);
    expect(preview.hltAmount).toBe('1200.0'); // 100 * 12
    expect(preview.price).toBe(12);
  });
  
  test('åº”è¯¥æ­£ç¡®å¤„ç†ä½™é¢ä¸è¶³é”™è¯¯', async () => {
    // æ¨¡æ‹Ÿä½™é¢ä¸è¶³
    mockProvider.mockBalance('0');
    
    await expect(hlt.buyTokens(100))
      .rejects
      .toThrow('USDTä½™é¢ä¸è¶³');
  });
});
```

### 2. é›†æˆæµ‹è¯•

```javascript
// ç«¯åˆ°ç«¯æµ‹è¯•æµç¨‹
describe('E2E Purchase Flow', () => {
  test('å®Œæ•´è´­ä¹°æµç¨‹', async () => {
    // 1. è¿æ¥é’±åŒ…
    await hlt.connectWallet();
    
    // 2. æ£€æŸ¥åˆå§‹çŠ¶æ€
    const initialInfo = await hlt.getUserInfo();
    expect(initialInfo.address).toBeTruthy();
    
    // 3. æ‰§è¡Œè´­ä¹°
    const result = await hlt.buyTokens(100);
    expect(result.transactionHash).toBeTruthy();
    
    // 4. éªŒè¯è´­ä¹°ç»“æœ
    const finalInfo = await hlt.getUserInfo();
    expect(parseFloat(finalInfo.purchased.hltAmount)).toBeGreaterThan(0);
  });
});
```

### 3. æµ‹è¯•ç½‘æµ‹è¯•æ¸…å•

- [ ] é’±åŒ…è¿æ¥åŠŸèƒ½
- [ ] ç½‘ç»œåˆ‡æ¢åŠŸèƒ½
- [ ] ä½™é¢æŸ¥è¯¢åŠŸèƒ½
- [ ] ä»£å¸è´­ä¹°åŠŸèƒ½
- [ ] æˆæƒæµç¨‹
- [ ] é”™è¯¯å¤„ç†
- [ ] äº‹ä»¶ç›‘å¬
- [ ] äº¤æ˜“çŠ¶æ€è·Ÿè¸ª
- [ ] é”ä»“çŠ¶æ€æŸ¥è¯¢
- [ ] å®æ—¶æ•°æ®æ›´æ–°

## â“ FAQ

### Q1: å¦‚ä½•å¤„ç†ç½‘ç»œåˆ‡æ¢ï¼Ÿ

```javascript
// ç›‘å¬ç½‘ç»œå˜åŒ–
window.ethereum.on('chainChanged', (chainId) => {
  // é‡æ–°åˆå§‹åŒ–åˆçº¦
  window.location.reload();
});

// æˆ–è€…åŠ¨æ€åˆ‡æ¢
function handleNetworkChange(chainId) {
  const networkConfig = getNetworkConfig(chainId);
  if (networkConfig) {
    // æ›´æ–°åˆçº¦åœ°å€
    hlt.updateContractAddresses(networkConfig.contracts);
  }
}
```

### Q2: å¦‚ä½•ä¼˜åŒ–Gasè´¹ç”¨ï¼Ÿ

```javascript
// 1. æ‰¹é‡æ“ä½œ
async function batchApproveAndBuy(usdtAmount) {
  // ä½¿ç”¨ multicall æˆ–æ‰¹é‡äº¤æ˜“
}

// 2. Gasä»·æ ¼ä¼˜åŒ–
async function getOptimalGasPrice() {
  const gasPrice = await provider.getGasPrice();
  // å¯ä»¥æ ¹æ®ç½‘ç»œæƒ…å†µè°ƒæ•´
  return gasPrice.mul(110).div(100); // å¢åŠ 10%ç¡®ä¿å¿«é€Ÿç¡®è®¤
}
```

### Q3: å¦‚ä½•å¤„ç†å¤§æ•°ç²¾åº¦é—®é¢˜ï¼Ÿ

```javascript
// ä½¿ç”¨ ethers.js çš„ BigNumber
import { BigNumber } from 'ethers';

// âœ… æ­£ç¡®çš„åšæ³•
const usdtAmount = ethers.utils.parseUnits('100.123456', 6);
const hltAmount = ethers.utils.parseEther('1200.0');

// âŒ é”™è¯¯çš„åšæ³•
const wrongAmount = 100.123456 * 1000000; // å¯èƒ½æœ‰ç²¾åº¦é—®é¢˜
```

### Q4: å¦‚ä½•å®ç°æ–­çº¿é‡è¿ï¼Ÿ

```javascript
class ConnectionManager {
  constructor(provider) {
    this.provider = provider;
    this.isConnected = false;
    this.reconnectAttempts = 0;
    this.maxReconnectAttempts = 5;
  }
  
  async checkConnection() {
    try {
      await this.provider.getNetwork();
      this.isConnected = true;
      this.reconnectAttempts = 0;
      return true;
    } catch (error) {
      this.isConnected = false;
      return false;
    }
  }
  
  async reconnect() {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      throw new Error('é‡è¿æ¬¡æ•°è¶…é™');
    }
    
    this.reconnectAttempts++;
    
    // ç­‰å¾…ä¸€æ®µæ—¶é—´åé‡è¯•
    await new Promise(resolve => setTimeout(resolve, 1000 * this.reconnectAttempts));
    
    return this.checkConnection();
  }
}
```

### Q5: å¦‚ä½•å®ç°äº¤æ˜“å†å²è®°å½•ï¼Ÿ

```javascript
// æŸ¥è¯¢ç”¨æˆ·äº¤æ˜“å†å²
async function getUserTransactionHistory(userAddress, fromBlock = 0) {
  const purchaseFilter = crowdsale.filters.TokensPurchased(userAddress);
  const events = await crowdsale.queryFilter(purchaseFilter, fromBlock);
  
  return events.map(event => ({
    transactionHash: event.transactionHash,
    blockNumber: event.blockNumber,
    timestamp: event.args.timestamp.toNumber(),
    usdtAmount: ethers.utils.formatUnits(event.args.usdtAmount, 6),
    hltAmount: ethers.utils.formatEther(event.args.hltAmount),
    lockTime: event.args.lockTime.toNumber()
  }));
}
```

---

## ğŸ“ æŠ€æœ¯æ”¯æŒ

å¦‚æœåœ¨é›†æˆè¿‡ç¨‹ä¸­é‡åˆ°é—®é¢˜ï¼Œè¯·ï¼š

1. æŸ¥çœ‹æœ¬æ–‡æ¡£çš„FAQéƒ¨åˆ†
2. æ£€æŸ¥åˆçº¦åœ°å€å’Œç½‘ç»œé…ç½®
3. æŸ¥çœ‹æµè§ˆå™¨æ§åˆ¶å°é”™è¯¯ä¿¡æ¯
4. è”ç³»æŠ€æœ¯æ”¯æŒå›¢é˜Ÿ

## ğŸ“š ç›¸å…³èµ„æº

- [ethers.js æ–‡æ¡£](https://docs.ethers.io/)
- [wagmi æ–‡æ¡£](https://wagmi.sh/)
- [OpenZeppelin åˆçº¦](https://docs.openzeppelin.com/contracts/)
- [BSC å¼€å‘æ–‡æ¡£](https://docs.binance.org/smart-chain/)
- [MetaMask å¼€å‘æ–‡æ¡£](https://docs.metamask.io/)

---

**ç¥æ‚¨é›†æˆé¡ºåˆ©ï¼** ğŸ‰